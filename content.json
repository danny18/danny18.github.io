{"meta":{"title":"Danny18的技术博客","subtitle":null,"description":null,"author":"Danny18","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"MessageQueue初探","slug":"MessageQueue","date":"2017-03-09T02:04:36.000Z","updated":"2017-03-09T02:05:17.177Z","comments":true,"path":"2017/03/09/MessageQueue/","link":"","permalink":"http://yoursite.com/2017/03/09/MessageQueue/","excerpt":"","text":"","categories":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/categories/MQ/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"}]},{"title":"Redis初探","slug":"Redis","date":"2017-03-09T02:03:28.000Z","updated":"2017-03-09T02:04:01.084Z","comments":true,"path":"2017/03/09/Redis/","link":"","permalink":"http://yoursite.com/2017/03/09/Redis/","excerpt":"","text":"","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"设计模式的几个原则","slug":"design patterns","date":"2017-03-04T03:49:10.000Z","updated":"2017-03-09T08:40:43.316Z","comments":true,"path":"2017/03/04/design patterns/","link":"","permalink":"http://yoursite.com/2017/03/04/design patterns/","excerpt":"","text":"如果将编程比作一门武功的话，代码实现就是拳脚招式，而设计模式好比这门武功的内功心法。学习设计模式的好处在于： 共享模式词汇：可以用更专业的术语和别人沟通； 明确每一种设计模式的使用边界，适用场景，因而得出其优劣之别； 避免无效设计和过度设计。设计的目标是解决问题，而不是运用模式。设计的初衷是高效，而不是复杂。 在学习设计模式之前，首先需要明确设计过程中的OO原则。对于这门内功而言，这些原则就是内功的总纲，要时刻牢记。 OO原则封装变化 把会变化的部分抽取出来并进行封装，以便以后可以轻易地改动或者扩充此部分，而不影响其他“不变”的地方。 多用组合，少用继承 组合的关系是“有一个”，而继承为“是一个”。某些松耦合的场景下，“有一个”比“是一个”更具有可扩展性。 针对接口编程，不针对实现编程 接口是制定标准，实现是接口在不同场景下的特性体现。在设计时优先考虑是否可以抽象出一个接口。 为交互对象之间的松耦合设计而努力 松耦合的意义在于交互双方并不了解对方的实现细节，通过简单的接口进行交互。 类应该对扩展开放，对修改关闭 该原则英文名称为Class-Close Principle：如果想要修改现有代码，则尽可能地增加代码而不是修改已有代码的逻辑。代码的设计应有清晰的思路，严格的控制，没有特别化的处理，拒绝不成熟的抽象和不确定的实现。 依赖抽象，不要依赖具体类 依赖倒置原则，Dependency Inversion Priciple。高层组件不应该依赖低层组件，二者都应该依赖于抽象。高层组件负责业务逻辑，低层组件负责具体操作。一般来说，高层组件会依赖低层组件完成相应的操作，但是这样做的坏处就是高层组件的代码很难复用在不同的场景下。“倒置”的含义是将高层组件和低层组件解耦合，通过接口进行依赖倒置（低层组件有可能依赖高层接口。） 遵守DIP的几个方法有：变量不去持有具体类的引用；不让类派生自具体类；不要覆盖基类中已实现的方法，基类中的方法应该由所有子类共享。 只和朋友交谈 最少知识原则，Least Knowledge。 别找我，我会找你 好莱坞原则。Don’t call me, I’ll call you.之所以叫做好莱坞原则，是取自好莱坞的经纪人，不想被你打扰，而是当有需要的时候去通知你。其核心是，用被通知的方式代替轮询。 好莱坞原则是控制反转（IoC）的基础。在控制反转当中，所有的组件都是被动的，由一个容器统一进行管理。而依赖注入（Dependency Injection）是控制反转的一个实现方式：所有组件之间的联系都是通过接口来实现的，组件对象的创建则通过容器+配置文件去完成。 好莱坞原则与依赖倒置原则都是规范使用接口的原则。区别在于：依赖倒置原则更注重在设计中避免高低层组件依赖，而好莱坞原则是更灵活地处理不同组件之间的关系，用挂钩的方式让低层组件能够参与到高层组件的运行中。 好莱坞原则大多用于框架FrameWork中，而传统的调用是Libaray的关系。 类应该只有一个改变的理由 单一责任原则。让类保持高内聚，低耦合。 设计模式的分类设计模式有多种分类方法。我采用如下的分类： 创建型Singleton，Abstract Factory，Factory Method 结构型Decorator，Proxy，Composite，Facade，Adapter 行为型Template Method，Command，Iterator,Observer,State,Strategy 学习过程中主要参考《head first in design patterns》和《Design Patterns: Elements of Reusable Object-Oriented Software》。最后，时刻提醒自己： KEEP SIMPLE!","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-03T10:44:03.376Z","updated":"2017-03-03T10:44:03.376Z","comments":true,"path":"2017/03/03/hello-world/","link":"","permalink":"http://yoursite.com/2017/03/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}