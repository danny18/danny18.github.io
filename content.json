{"meta":{"title":"Danny18的技术博客","subtitle":null,"description":null,"author":"Danny18","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"docker swarm mode简单应用","slug":"docker-swarm-start","date":"2017-06-08T06:38:04.000Z","updated":"2017-06-08T06:42:23.963Z","comments":true,"path":"2017/06/08/docker-swarm-start/","link":"","permalink":"http://yoursite.com/2017/06/08/docker-swarm-start/","excerpt":"","text":"","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker swarm的核心概念","slug":"docker-swarm-mode-key-concepts","date":"2017-05-19T08:34:55.000Z","updated":"2017-06-08T06:34:54.080Z","comments":true,"path":"2017/05/19/docker-swarm-mode-key-concepts/","link":"","permalink":"http://yoursite.com/2017/05/19/docker-swarm-mode-key-concepts/","excerpt":"","text":"什么是swarmswarm是一个Docker engine或Docker节点的集群。通过Docker Engine CLI和API去管理swarm节点，部署和编排服务。 当使用非swarm mode运行docker时，执行container命令。当使用swarm mode时，则对service进行编排。可以在同一个docker实例上运行swarm服务和独立的container。 什么是节点节点是swarm中一个Docker engine的实例。在一台物理机或者云服务器上可以运行一个或多个节点，不过生产环境中swarm的部署通常会在多台物理机或者云服务器上。 通过提交一个服务定义（service definition）到一个manager node来部署应用。而manager node分发工作单元（called tasks）到worker node上。管理节点同时还负责集群的管理和任务的编排，管理节点之间会选举出一个leader来领导编排任务。 工作节点接收执行任务，缺省情况下，管理节点也和工作节点一样运行服务，不过你也可以单独配置管理节点去做纯管理的事情（manager-only）。每个工作节点上面有一个代理，负责报告任务的执行情况。 工作节点会通知管理节点当前运行状态从而管理节点可以保持每个工作节点的理想状态。 服务和任务服务定义了一批任务。一个服务是swarm系统的核心结构，同时也是主要的交互接口。 服务包括复制服务模型（replicated service model）和全局服务模型（global service model）。rsm可以在节点上创建多个复制服务，而gsm会在每个可用节点上运行一个服务的任务。 一个任务包括一个container和container执行的命令，是swarm中最小的调度单元。管理节点根据服务规模中设定的复制节点，安排工作节点上运行的任务。当一个任务被安排在一个节点上运行时，就不能移动到另外的节点上。 负载均衡swarm manager使用入口负载均衡（ingress load balancing）。可以自己指定一个服务的发布端口，也可以由swarm manager从30000-32767之间选择一个端口。","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker swarm mode概述","slug":"docker-swarm-mode-overview","date":"2017-05-19T08:26:00.000Z","updated":"2017-06-08T06:32:03.029Z","comments":true,"path":"2017/05/19/docker-swarm-mode-overview/","link":"","permalink":"http://yoursite.com/2017/05/19/docker-swarm-mode-overview/","excerpt":"","text":"Docker Engine从v1.12.0之后开始支持和集成swarm mode。可以使用Docker CLI去创建swarm，部署应用服务和进行swarm集群管理。 Feature highlightsDocker Engine集成集群管理使用Docker Engine CLI创建swarm集群，部署应用服务，不需要额外的编排软件（orchestration software）创建和管理swarm。 去中心设计在部署阶段，Docker Engine并不区分节点角色之间的差异，而在运行阶段去区分不同的节点类型。你可以使用Docker Engine部署manager和worker这两种类型的节点。因此你可以使用一个磁盘镜像（single disk image）去建立整个swarm网络。 声明式服务模型Docker Engine使用声明式方法定义应用程序栈中的不同服务的期望状态（desired state）。 Scaling你可以声明每个服务想要运行的任务数目。swarm manager会根据声明自动调整任务数目以达到期望的运行状态。 Desired state reconciliationswarm manager持续监控集群状态，并不断调整实际状态以达到期望状态。比如启动了一个有10个复制的服务，一个宿主机上的两个复制挂掉了，swarm manager会创建两个新的复制来保持整个集群的运行状态。 多宿主机网络可以为服务指定一个覆盖网络（overlay network）。swarm manager会自动给container分配地址。 服务发现swarm manager会给每一个service分配一个独有的DNS。可以通过swarm内置的DNS模块去访问swarm中运行的container。 负载均衡swarm支持将服务的端口暴露给外部的负载均衡器。同时在内部，swarm也允许给指定节点分发服务。 安全设计支持TLS传输协议和自签证书。 滚动更新swarm manager可以控制不同节点上服务部署的延迟时间。如果出现错误，可以快速的回滚到之前的版本。","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"MessageQueue初探","slug":"MessageQueue","date":"2017-03-09T02:04:36.000Z","updated":"2017-03-09T02:05:17.177Z","comments":true,"path":"2017/03/09/MessageQueue/","link":"","permalink":"http://yoursite.com/2017/03/09/MessageQueue/","excerpt":"","text":"","categories":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/categories/MQ/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"}]},{"title":"Redis初探","slug":"Redis","date":"2017-03-09T02:03:28.000Z","updated":"2017-03-09T02:04:01.084Z","comments":true,"path":"2017/03/09/Redis/","link":"","permalink":"http://yoursite.com/2017/03/09/Redis/","excerpt":"","text":"","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"设计模式的几个原则","slug":"design patterns","date":"2017-03-04T03:49:10.000Z","updated":"2017-03-09T08:45:12.747Z","comments":true,"path":"2017/03/04/design patterns/","link":"","permalink":"http://yoursite.com/2017/03/04/design patterns/","excerpt":"","text":"如果将编程比作一门武功的话，代码实现就是拳脚招式，而设计模式好比这门武功的内功心法。学习设计模式的好处在于： 共享模式词汇：可以用更专业的术语和别人沟通； 明确每一种设计模式的使用边界，适用场景，因而得出其优劣之别； 避免无效设计和过度设计。设计的目标是解决问题，而不是运用模式。设计的初衷是高效，而不是复杂。 在学习设计模式之前，首先需要明确设计过程中的OO原则。对于这门内功而言，这些原则就是内功的总纲，要时刻牢记。 OO原则封装变化 把会变化的部分抽取出来并进行封装，以便以后可以轻易地改动或者扩充此部分，而不影响其他“不变”的地方。 多用组合，少用继承 组合的关系是“有一个”，而继承为“是一个”。某些松耦合的场景下，“有一个”比“是一个”更具有可扩展性。 针对接口编程，不针对实现编程 接口是制定标准，实现是接口在不同场景下的特性体现。在设计时优先考虑是否可以抽象出一个接口。 为交互对象之间的松耦合设计而努力 松耦合的意义在于交互双方并不了解对方的实现细节，通过简单的接口进行交互。 类应该对扩展开放，对修改关闭 该原则英文名称为Class-Close Principle：如果想要修改现有代码，则尽可能地增加代码而不是修改已有代码的逻辑。代码的设计应有清晰的思路，严格的控制，没有特别化的处理，拒绝不成熟的抽象和不确定的实现。 依赖抽象，不要依赖具体类 依赖倒置原则，Dependency Inversion Priciple。高层组件不应该依赖低层组件，二者都应该依赖于抽象。高层组件负责业务逻辑，低层组件负责具体操作。一般来说，高层组件会依赖低层组件完成相应的操作，但是这样做的坏处就是高层组件的代码很难复用在不同的场景下。“倒置”的含义是将高层组件和低层组件解耦合，通过接口进行依赖倒置（低层组件有可能依赖高层接口。） 遵守DIP的几个方法有：变量不去持有具体类的引用；不让类派生自具体类；不要覆盖基类中已实现的方法，基类中的方法应该由所有子类共享。 只和朋友交谈 最少知识原则，Least Knowledge。 别找我，我会找你 好莱坞原则。Don’t call me, I’ll call you.之所以叫做好莱坞原则，是取自好莱坞的经纪人，不想被你打扰，而是当有需要的时候去通知你。其核心是，用被通知的方式代替轮询。 好莱坞原则是控制反转（IoC）的基础。在控制反转当中，所有的组件都是被动的，由一个容器统一进行管理。而依赖注入（Dependency Injection）是控制反转的一个实现方式：所有组件之间的联系都是通过接口来实现的，组件对象的创建则通过容器+配置文件去完成。 好莱坞原则与依赖倒置原则都是规范使用接口的原则。区别在于：依赖倒置原则更注重在设计中避免高低层组件依赖，而好莱坞原则是更灵活地处理不同组件之间的关系，用挂钩的方式让低层组件能够参与到高层组件的运行中。 好莱坞原则大多用于框架FrameWork中，而传统的调用是Libaray的关系。 类应该只有一个改变的理由 单一责任原则。让类保持高内聚，低耦合。 设计模式的分类设计模式有多种分类方法。我采用如下的分类： 创建型Singleton，Abstract Factory，Factory Method 结构型Decorator，Proxy，Composite，Facade，Adapter 行为型Template Method，Command，Iterator, Observer, State, Strategy 学习过程中主要参考《head first in design patterns》和《Design Patterns: Elements of Reusable Object-Oriented Software》。最后，时刻提醒自己： KEEP SIMPLE!","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]}]}